## 그래프1

### 간선리스트
* 배열을 이용해서 구현
* 간선을 모두 저장하고 있다.
* E라는 배열에 간선을 모두 저장
* 인접리스트를 사용해야 하는데 라이브러리 사용이 금지되어 있을 경우 사용한다. (대중적인 자료구조는 아니다.)

```java
[1] --- [5] --- [4] --- [6]
   \     |     / |
    \    |    /  |
     \   |   /   |       
      \  |  /    |
       \ | /     |
        [2] --- [3] 
```
```java
E[0] = 1 2        E[8] = 2 1
E[1] = 1 5        E[9] = 5 1
E[2] = 2 3        E[10] = 3 2
E[3] = 2 4        E[11] = 4 2
E[4] = 2 5        E[12] = 5 2
E[5] = 5 4        E[13] = 4 5
E[6] = 4 3        E[14] = 3 4
E[7] = 4 6        E[15] = 6 4
```
```java
// 정렬 후
// 각 간선의 앞 정점을 기준으로 개수를 샌다. (i=1, 2, 3, 4, 5, 6)

E[0] = 1 2      E[8] = 4 2
E[1] = 1 5      E[9] = 4 3
E[2] = 2 1      E[10] = 4 5
E[3] = 2 3      E[11] = 4 6
E[4] = 2 4      E[12] = 5 1
E[5] = 2 5      E[13] = 5 2
E[6] = 3 2      E[14] = 5 4
E[7] = 3 4      E[15] = 6 4

  i    |   0   1   2   3   4   5   6
=======================================
cnt[i] |   0   2   4   2   4   3   1
```
```java
// 누적합 구하기
for(int i=1; i<N; i++){
	cnt[i] = cnt[i-1] + cnt[i];
}

  i    |   0   1   2   3   4   5   6
=======================================
cnt[i] |   0   2   6   8  12  15  16

=> 정점이 몇번 인덱스부터 몇번인덱스까지 저장되어 있는지 확인가능하다.
ex) 1번 정점 : 인덱스 0 ~ 1
    2번 정점 : 인덱스 2 ~ 5
    3번 정점 : 인덱스 6 ~ 7
    4번 정점 : 인덱스 8 ~ 11
    5번 정점 : 인덱스 12 ~ 14
    6번 정점 : 인덱스 15

```

</br>

### 인접행렬
* 정점의 개수를 V라고 했을 때
* V * V 크기의 이차원 배열을 이용한다.
* A[i][j] = 1 (i -> j 간선이 있을 때)
* A[i][j] = 0 (i -> j 간선이 없을 때

```java
[1] --- [5] --- [4] --- [6]
   \     |     / |
    \    |    /  |
     \   |   /   |       
      \  |  /    |
       \ | /     |
        [2] --- [3] 
```

```java
    |    1    2    3    4    5    6
=====================================
1   |    0    1    0    0    1    0
2   |    1    0    1    1    1    0
3   |    0    1    0    1    0    0
4   |    0    1    1    0    1    1
5   |    1    1    0    1    0    0
6   |    0    0    0    1    0    0
```

</br>

* 간선에 가중치가 있을 경우
  * A[i][j] = w (i -> j 간선이 있을 때 그 가중치)
  * A[i][j] = 0 (i -> j 간선이 없을 때)
```java
     7       7       7
[1] --- [5] --- [4] --- [6]
   \     |     / |
    \    |    /  |
  2  \ 1 | 3 /   | 1
      \  |  /    |
       \ | /  2  |
        [2] --- [3]  
```
```java
    |    1    2    3    4    5    6
=====================================
1   |    0    2    0    0    7    0
2   |    2    0    2    3    1    0
3   |    0    2    0    1    0    0
4   |    0    3    1    0    7    7
5   |    7    1    0    7    0    0
6   |    0    0    0    7    0    0
```

</br>

### 인접리스트
* 리스트를 이용해서 구현한다.
* A[i] = i와 연결된 정점(간선)을 리스트로 포함하고 있음
* 리스트의 크기를 동적으로 변경할 수 있어야 한다.
* 링크드 리스트나 길이를 동적으로 변경할 수 있는 배열을 사용한다.
* 한정점과 연결된 모든 간선을 구할 때 걸리는 시간복잡도 = O(차수)

```java
[1] --- [5] --- [4] --- [6]
   \     |     / |
    \    |    /  |
     \   |   /   |       
      \  |  /    |
       \ | /     |
        [2] --- [3] 
```
```java
A[1] = 2 5
A[2] = 1 3 4 5
A[3] = 2 4
A[4] = 3 5 2 6
A[5] = 1 2 4
A[6] = 4
```

</br>

* 간선에 가중치가 있을 경우 : (정점,가중치)
```java
     7       7       7
[1] --- [5] --- [4] --- [6]
   \     |     / |
    \    |    /  |
  2  \ 1 | 3 /   | 1
      \  |  /    |
       \ | /  2  |
        [2] --- [3]  
```
```java
A[1] = (2,2) (5,7)
A[2] = (1,2) (3,2) (4,3) (5,1)
A[3] = (2,2) (4,1)
A[4] = (3,1) (5,7) (2,3) (6,7)
A[5] = (1,7) (2,1) (4,7)
A[6] = (4,7)
```


## 그래프의 탐색 (DFS, BFS)
* 목적 : 임의의 정점에서 시작하여 연결되어 있는 모든 정점을 1번씩 방문하는 것

### DFS (Depth First Search) : 깊이 우선 탐색
* 스택, 재귀함수로 구현
* 스택 ↔ 재귀함수의 결과 순서는 다르다.
* 스택을 이용해서 갈 수 있는 만큼 최대한 많이 가고
* 갈 수 없으면 이전 정점으로 돌아간다.

```java
[1] --- [5] --- [4] --- [6]
   \     |     / |
    \    |    /  |
     \   |   /   |       
      \  |  /    |
       \ | /     |
        [2] --- [3] 
	
// 현재 정점 : 1
// 순서 : 1
// 스택 : 1
// 현재 정점 1에서 2와 5중에 아무거나 하나만 먼저 가야한다. 두개 다 담지 않음.

// 현재 정점 : 2
// 순서 : 1 2 
// 스택 : 1 2 
// 현재 정점 2에서 3과 5중에 아무거나 하나만 먼저 가야한다.

// 현재 정점 : 3
// 순서 : 1 2 3
// 스택 : 1 2 3

// 현재 정점 : 4
// 순서 : 1 2 3 4
// 스택 : 1 2 3 4

// 현재 정점 : 5
// 순서 : 1 2 3 4 5
// 스택 : 1 2 3 4 5
// 현재 정점 5에서 갈 수 있는 정점이 없으므로 5를 pop하고 4로 간다

// 현재 정점 : 4
// 순서 : 1 2 3 4 5 
// 스택 : 1 2 3 4 

// 현재 정점 : 6
// 순서 : 1 2 3 4 5 6
// 스택 : 1 2 3 4 6
```
```java
// check[i] : 방문=1, 방문안함=0

   i     |    1    2    3    4    5    6
==========================================
check[i] |    1    1    1    1    1    1
```

```java
// 재귀호출 구현
void dfs(int x) {
    check[x] = true; // 방문 시 true
    
    // 인접 정점 이동
    for(int i=1; i<=N; i++) {
        if(list[x][i] == 1 && check[i] == false) {  // list : 인접 리스트
	    dfs(i);
	}
    }
}
```

```java
public class Study_DFS_Recursion {

    // 방문처리에 사용 할 배열선언
    static boolean[] vistied = new boolean[9];
	
    // 그림예시 그래프의 연결상태를 2차원 배열로 표현
    // 인덱스가 각각의 노드번호가 될 수 있게 0번인덱스는 아무것도 없는 상태라고 생각하시면됩니다.
    static int[][] graph = {{}, {2,3,8}, {1,6,8}, {1,5}, {5,7}, {3,4,7}, {2}, {4,5}, {1,2}};
	
    public static void main(String[] args) {
        dfs(1);
    }
	
    static void dfs(int nodeIndex) {
	// 방문 처리
	vistied[nodeIndex] = true;
		
	// 방문 노드 출력
	System.out.print(nodeIndex + " -> ");
		
	// 방문한 노드에 인접한 노드 찾기
	for (int node : graph[nodeIndex]) {
	    // 인접한 노드가 방문한 적이 없다면 DFS 수행
	    if(!vistied[node]) {
		dfs(node);
	    }
        }
    }
}
```

```java
public class Study_DFS_stack {

    // 방문처리에 사용 할 배열선언
    static boolean[] vistied = new boolean[9];
	
    // 그림예시 그래프의 연결상태를 2차원 배열로 표현
    // 인덱스가 각각의 노드번호가 될 수 있게 0번인덱스는 아무것도 없는 상태라고 생각하시면됩니다.
    // 인접 리스트
    static int[][] graph = {{}, {2,3,8}, {1,6,8}, {1,5}, {5,7}, {3,4,7}, {2}, {4,5}, {1,2}};
	
    // DFS 사용 할 스택
    static Stack<Integer> stack = new Stack<>();
	
    public static void main(String[] args) {
		
	// 시작 노드를 스택에 넣어줍니다.
	stack.push(1);
	// 시작 노드 방문처리
	vistied[1] = true;
		
	// 스택이 비어있지 않으면 계속 반복
	while(!stack.isEmpty()) {
	
    	    // 스택에서 하나를 꺼냅니다.
	    int nodeIndex = stack.pop();
			
	    // 방문 노드 출력
	    System.out.print(nodeIndex + " -> ");
			
	    // 꺼낸 노드와 인접한 노드 찾기
            for (int LinkedNode : graph[nodeIndex]) {
		// 인접한 노드를 방문하지 않았을 경우에 스택에 넣고 방문처리 
		if(!vistied[LinkedNode]) {
		    stack.push(LinkedNode);
		    vistied[LinkedNode] = true;
		}
            }
	}
    }
}
```
</br>

### BFS (Breadth First Search) : 너비 우선 탐색
* 큐 구현
* 큐를 이용해서 지금 위치에서 갈 수 있는 것을 모두 큐에 넣는 방식
* 큐에 넣을 때 방문했다고 체크해야 한다.
* 최단거리 구할 때 사용한다.

```java
[1] --- [5] --- [4] --- [6]
   \     |     / |
    \    |    /  |
     \   |   /   |       
      \  |  /    |
       \ | /     |
        [2] --- [3] 
	
// 현재 정점 : 1
// 순서 : 1 2 5
// 큐 : 1 2 5
// 2와 5중에 둘다 큐에 담는다.

// 현재 정점 : 2
// 순서 : 1 2 5 3
// 큐 : 2 5 3 
// 1을 pop하고 다음 정점 2에서 갈 수 있는 것은 3만 있음

// 현재 정점 : 5
// 순서 : 1 2 5 3 4
// 큐 : 5 3 4
// 2를 pop 하고 다음 정점 5에서 갈 수 있는 4를 방문한다.

// 현재 정점 : 3
// 순서 : 1 2 5 3 4
// 큐 : 3 4
// 5를 pop 하고 다음 정점 3에서 갈 수 있는 곳이 없어 다음 정점으로 pass

// 현재 정점 : 4
// 순서 : 1 2 5 3 4
// 큐 : 4 6
// 3을 pop하고 4에서 갈 수 있는 6을 방문하고 탐색 종료된다.
```

```java
// 인접 리스트 구현

```

### 연결 요소(Connected Component)
* 그래프가 아래 그림과 같이 나누어진 각각의 그래프를 연결 요소라고 한다. (연결 요소 2개)
```java
[1]--[5]    [4]--[6]
   \  |      |   /
    \ |      |  /
     \|      | /
     [2]    [3]
```

### 이분 그래프(Bipartite Graph)
* 그래프를 아래와 같이 A와 B로 나눌 수 있으면 이분 그래프라고 한다.
  * A에 포함되어 있는 정점끼리 연결된 간선이 없음
  * B에 포함되어 있는 정점끼리 연결된 간선이 없음
  * 모든 간선의 한 끝점은 A에, 다른 끝점은 B에 연결되어야 함.

```java
/*
1 → 4   4 → 2
2 → 3   
1 → 6   6 → 5
*/

  A               B
=====           =====
[ 1 ]           [ 4 ] 

[ 2 ]           [ 3 ]

[ 3 ]           [ 6 ]  
```

# 08.기본수학2 Summary

## 소수 구하는 알고리즘
1) 기본법 ([Q1978](Q1978.java))
2) 제곱근을 이용한 기본 판별법
3) 에라토스테네스의 체 ([Q1929_2](Q1929_2.java))
<br/>

## 소인수분해 문제([Q11653](Q11653.java))
<br/>
   
## 소수 구하기 문제2
기존 기본법으로 구현한 로직 사용 시 시간 초과됨([Q1929](Q1929.java))   
<br/>
   
## 왜 소수 문제가 많이 나오고 중요하게 다루는가?
#### 1️⃣ 암호 때문이다. 임의의 수를 곱하기는 쉽지만 역으로 소인수분해 하는 것은 어렵다.
<br/>
#### 2️⃣ 129자리 수를 소인수 분해 할 수 있는가?
```java
114381625757888867669235779976146612010218296721242362562561842935706935245733897830597123563958705058989075147599290026879543541
```
- 이 수는 실제로 RSA-129의 공개키였고 현재는 풀린 129자리의 수이다.   
- 위 문제를 컴퓨터로 푼다면 쉽게 풀릴 것 같지만 이는 오산이다.   
- 실제로 위 문제를 풀기위해서 약 1600대의 컴퓨터와 600명의 사람이 모여 6개월동안 진행했다.
<br/>
#### 3️⃣ RSA-129 = 64자리 * 65자리
```java
3490529510847650949147849619903898133417764638493387843990820577 * 32769132993266709549961988190834461413177642967992942539798288533
```
- 위에 두 수(64자리 * 65자리)는 소수이다   
<br/>
#### 4️⃣ 617 자리의 수는 얼마나 오래 걸릴지 가늠이 안된다. 그래서 실제로도 대부분의 인터넷뱅킹도 RSA-2048 을 쓰고 있다.
```java
RSA-2048 = 25195908475657893494027183240048398571429282126204032027777137836043662020707595556264018525880784406918290641249515082189298559149176184502808489120072844992687392807287776735971418347270261896375014971824691165077613379859095700097330459748808428401797429100642458691817195118746121515172654632282216869987549182422433637259085141865462043576798423387184774447920739934236584823824281198163815010674810451660377306056201619676256133844143603833904414952634432190114657544454178424020924616515723350778707749817125772467962926386356373289912154831438167899885040445364023527381951378636564391212010397122822120720357
```
<br/>
#### 따라서 '에라토스테네스의 체'를 숙지하기로 함❗
<br/>
## 에라토스테네스의 체([Q1929_2](Q1929_2.java))
```java
i = 2 부터 루트N 이하까지 반복하여 자연수들 중 k를 제외한 k의 배수들을 제외시킨다.
i = 2 이면 2를 제외한 2의 배수를 모두 지워주고,
i = 3 이면 3 을 제외한 3의 배수를 모두 지워주고,
(4는 이미 i = 2 에서 제외되어 넘어간다.)
i = 5 이면 5 를 제외한 5의 배수를 모두 지워주고..
이렇게 하여 i = √N 까지 반복하는 방법이다.
```

```java
// 에라토스테네스의 체
public static void get_prime() {
	// 소수가 아닌 index = true
	// 소수인 index = false		
	prime[0] = prime[1] = true;

	for(int i=2; i<=Math.sqrt(prime.length); i++) { // Math.sqrt(N) : 루트N
		if(prime[i]) {
			continue;
		}
		// N = 16
		// i=2, j=4; j<17; 4+2=6    4 6 8 10 12 14 16 = true  
		// i=3, j=9; j<17; 9+3=12	9 12 15 = true
		// i=4, j=16; j<17 			16 = true
		// 정석대로라면 j = i * 2 부터 시작이지만 이미 2의 배수가 걸러졌기때문에 i 의 제곱수부터 시작해도 된다.
		for(int j=i*i; j<prime.length; j=j+i) {
			prime[j] = true;
		}
	}
	// 배열 index 가 소수라면 false 로, 아니라면 true 로 완성됨		
}
```

## Math.sqrt(number)

```java
System.out.println("9의 제곱근 : " + Math.sqrt(9));  	// 3
System.out.println("20의 제곱근 : " + Math.sqrt(20));	// 4.472135
System.out.println("50의 제곱근 : " + Math.sqrt(50));	// 7.071067
System.out.println("100의 제곱근 : " + Math.sqrt(100));	// 10.0
System.out.println("NaN의 제곱근 : " + Math.sqrt(Double.NaN));	// NaN
System.out.println("-1의 제곱근 : " + Math.sqrt(-1));	// NaN
			
//	int N = Math.sqrt(120); 에러
double M = Math.sqrt(120);
System.out.println(M);
```
<br/>

## 베르트랑 공준([Q4948](Q4948.java))
```java
베르트랑 공준 : 임의의 자연수 n에 대하여, n보다 크고, 2n보다 작거나 같은 소수는 적어도 하나 존재한다
```
예제 입력 (입력의 마지막에는 0이 주어진다.) 할 때 어떻게 처리할지 생각했음.   
<br/>

## 골드바흐의 추측([Q9020](Q9020.java))
```java
골드바흐의 추측
- 2보다 큰 모든 짝수는 두 소수의 합으로 나타낼 수 있다는 것
- 짝수를 두 소수의 합으로 나타내는 표현을 그 수의 골드바흐 파티션이라고 한다.
```
<br/>

#### 로직 : 짝수 n 을 절반을 나누어서 검사하면 된다.
- n = p + q ( p 와 q는 소수 ) 일 때
- 예로들어 n = 16 이 주어진다고 해보자.   
- 그럼 일단 p 와 q 에 16을 절반으로 나눈 8 을 각각 저장한다고 생각하자.   
- 그리고 p 와 q 가 소수가 아니라면 p 는 1 감소, q 는 1 증가시키면서 p 와 q 가 소수일 때 까지 찾는 것이다.   

```java
p	q	n = p + q	True/False
------------------------------------------
8	8	16		False
7	9	16		False
6	10	16		False
5	11	16		True
4	12	16		False
3	13	16		True
2	14	16		False
```





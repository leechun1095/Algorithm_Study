# 그래프
- 강의 연결요소~
<!--

|no|문제|풀이|비고|
|---|----|----|----|
||[](https://www.acmicpc.net/problem/)|[Q.java](dynamic1/Q.java)||
||[](https://www.acmicpc.net/problem/)|[Q.java](dynamic1/Q.java)||
||[](https://www.acmicpc.net/problem/)|[Q.java](dynamic1/Q.java)||
||[](https://www.acmicpc.net/problem/)|[Q.java](dynamic1/Q.java)||
||[](https://www.acmicpc.net/problem/)|[Q.java](dynamic1/Q.java)||
-->

## 그래프
- 자료구조
- 문제의 상황을 그래프화 모델링하여 문제를 푼다.
- 정점
- 간선
### 경로
- 정점 A -> 정점 B 로 가는 경로
### 사이클
- 정점 A -> 정점 A 로 돌아오는 경로
### 단순경로와 단순사이클
- 같은 정점을 두 번 이상 방문하지 않는 경로/사이클
- 일반적으로 경로/사이클은 단순 경로/사이클을 의미한다.
### 방향 있는 그래프
- 간선에 방향이 있다.
- A->C (O) C->A (X)
### 방향 없는 그래프(양방향 그래프)
- 간선에 방향이 없다.
- A-C: A->C (O) C->A (O)
### 간선 여러개
- 두 정점 사이에 간선이 여러 개일 수도 있다.
- 서로 다른 두 간선
### 루프
- 간선의 양 끝 점이 같은 경우가 있다.
- A->A
### 가중치
- 간선에 써 있는 값
- A에서 B로 이동하는 거리, 시간, 비용 등
- 디폴트: 1
### 차수
- 정점과 연결되어 있는 간선의 개수

## 그래프 저장 방법
### 1. 인접 행렬
- 정점의 개수를 V라고 했을 때
- V X V 크기의 이차원 배열을 이용
- A[i][k] = 간선이 있으면 w(가중치), 없으면 0 저장
### 2. 인접 리스트
- (길이가 동적인)리스트를 이용
- A[i] = i와 연결된 모든 정점을 리스트 형태로 저장
- 간선이 있을 때만 저장
- 한 정점과 연결된 모든 정점을 찾을 때
### 3. 간선 리스트
- 배열을 이용
- 간선을 모두 저장

## 그래프의 탐색
- 목적: 임의의 정점에서 시작해서 연결되어 있는 모든 정점을 1번씩 방문하는 것
- DFS vs BFS: 어떤 순서로 간선을 방문할 것인가
### DFS(Depth First Search): 깊이 우선 탐색
- Stack 이용
- 스택을 이용해서 갈 수 있는 만큼 최대한 많이 가고,
- 갈 수 없으면 이전 정점으로 돌아간다.
### BFS(Breadth First Search): 너비 우선 탐색
- Queue 이용
- 큐를 이용해서 지금 위치에서 갈 수 있는 것을 모두 큐에 넣는 방식
- 큐에 넣을 때 방문했다고 체크해야 한다.

```java
```


















